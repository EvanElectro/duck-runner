<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Runner Game</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            outline: none;
            touch-action: none;
            tabindex: "-1";
        }
        #mute-button {
            position: absolute;
            top: 5vh;
            left: 5vw;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        #mute-button:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }
        #score-display {
            position: absolute;
            bottom: 20vh;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 5vw;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        #lives-display {
            position: absolute;
            top: 5vh;
            right: 5vw;
            z-index: 100;
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            align-items: center;
            gap: 10px;
            max-width: 200px;
        }
        #lives-label {
            color: white;
            font-size: 4vw;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        .life-circle {
            width: 5vw;
            height: 5vw;
            background-color: #FF6347;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #instructions {
            position: absolute;
            bottom: 5vh;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 3vw;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87CEEB, #4682B4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #start-title {
            color: white;
            font-size: 10vw;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #start-subtitle {
            color: white;
            font-size: 4vw;
            margin-bottom: 40px;
            text-align: center;
            max-width: 80vw;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        #start-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        #controls-info {
            margin-top: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 3vw;
        }
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        #pause-message {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 4vw;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
            font-size: 4vw;
        }
        #restart-button, #resume-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 5px;
        }
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20vw;
            color: white;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: none;
            font-weight: bold;
            transition: transform 0.5s ease, opacity 0.5s ease;
            opacity: 1;
            animation: pulse 0.5s infinite alternate;
        }
        #countdown.animate {
            transform: translate(-50%, -50%) scale(2);
            opacity: 0;
        }
        @keyframes pulse {
            from { text-shadow: 0 0 20px rgba(0, 0, 0, 0.8); }
            to { text-shadow: 0 0 30px rgba(255, 255, 0, 0.8), 0 0 40px rgba(0, 255, 255, 0.6); }
        }
        #ready-text {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8vw;
            color: white;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: none;
            font-weight: bold;
        }
        @media (max-width: 600px) {
            #start-button {
                padding: 20px 50px;
                font-size: 30px;
            }
            #restart-button, #resume-button {
                padding: 15px 30px;
                font-size: 20px;
            }
            #instructions {
                bottom: 10vh;
                font-size: 2.5vw;
                line-height: 1.2;
            }
            #lives-display {
                gap: 5px;
            }
            #lives-label {
                font-size: 3vw;
            }
            .life-circle {
                width: 4vw;
                height: 4vw;
            }
            #mute-button {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }
        @media (min-width: 1024px) {
            #score-display {
                bottom: 25vh;
                font-size: 2rem;
            }
            #instructions {
                font-size: 1.5rem;
            }
            #lives-display {
                gap: 8px;
            }
            #lives-label {
                font-size: 1rem;
            }
            .life-circle {
                width: 1.5rem;
                height: 1.5rem;
            }
            #start-title {
                font-size: 4rem;
                margin-bottom: 1rem;
            }
            #start-subtitle {
                font-size: 1.5rem;
                margin-bottom: 2rem;
                max-width: 600px;
            }
            #start-button {
                padding: 10px 30px;
                font-size: 1.2rem;
            }
            #controls-info {
                font-size: 1rem;
                margin-top: 1.5rem;
                padding: 10px;
                max-width: 400px;
            }
            #mute-button {
                width: 50px;
                height: 50px;
                font-size: 24px;
                top: 20px;
                left: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container" tabindex="-1">
        <audio id="background-music" loop>
            <source src="Starlight Blue Background.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
        <button id="mute-button">🔊</button>
        <div id="lives-display">
            <div id="lives-label">Lives:</div>
            <div class="lives-container"></div>
        </div>
        <div id="instructions">
            Jump: SPACE / UP ARROW / Tap top half<br>
            Duck: DOWN ARROW / Tap bottom half<br>
            Pause: P
        </div>
        <div id="score-display">Score: 0</div>
        <div id="countdown">3</div>
        <div id="ready-text">GET READY!</div>
        <div id="start-screen">
            <h1 id="start-title">Duck Runner</h1>
            <p id="start-subtitle">Jump over blocks and duck under ducks in this fast-paced 3D endless runner!</p>
            <button id="start-button">Start Game</button>
            <div id="controls-info">
                <p>Controls:</p>
                <p>Jump: SPACE / UP ARROW / Tap top half</p>
                <p>Duck: DOWN ARROW / Tap bottom half</p>
                <p>Pause: P</p>
            </div>
        </div>
        <div id="pause-screen">
            <div id="pause-message">
                <h2>Game Paused</h2>
                <p>Press P or click below to resume</p>
                <button id="resume-button">Resume</button>
            </div>
        </div>
        <div id="game-over">
            <h2>Game Over!</h2>
            <p id="final-score">Final Score: 0</p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let scene, camera, renderer, player, ground, obstacles = [];
            let score = 0, lives = 3, isJumping = false, isDucking = false, isInDuckAnimation = false,
                duckAnimationPhase = 0, isInvincible = false, gameRunning = false, gameStarted = false,
                gamePaused = false, isDownKeyPressed = false, jumpAnimationId = null, duckAnimationId = null,
                jumpHeight = 0, jumpProgress = 0, duckProgress = 0, duckHeight = 1.0;
            const DUCK_DURATION = 500, DUCK_DOWN_PERCENT = 0.3, DUCK_HOLD_PERCENT = 0.4,
                  DUCK_UP_PERCENT = 0.3, JUMP_DURATION = 500;
            const MAX_DIFFICULTY_SCORE = 120, INITIAL_OBSTACLE_SPEED = 0.2, MAX_OBSTACLE_SPEED = 0.7,
                  MAX_DIFFICULTY_FACTOR = 4.0;
            let obstacleSpeed = INITIAL_OBSTACLE_SPEED, baseDifficulty = 1.0, difficultyFactor = 1.0;
            const INITIAL_MIN_OBSTACLE_DISTANCE = 1.0, MIN_OBSTACLE_DISTANCE_AT_MAX = 0.4,
                  EARLY_GAME_MIN_SPACING = 1.0, EARLY_GAME_MAX_SPACING = 1.5, EARLY_GAME_THRESHOLD = 25,
                  CHALLENGE_THRESHOLD = 40;
            let minObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE, lastObstacleTime = 0,
                nextObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE;
            let patternMode = false, currentPatternIndex = 0, currentPattern = [], burstMode = false,
                burstCount = 0, maxBurstCount = 0, inCooldownPhase = false, cooldownEndTime = 0;
            let inputsActive = true, countdownActive = false, countdownValue = 3;
            const PLAYER_HEIGHT = 1.0, PLAYER_WIDTH = 0.5, PLAYER_DEPTH = 0.5, JUMP_HEIGHT = 1.5,
                  DUCK_HEIGHT = 0.5, DEFAULT_Y = PLAYER_HEIGHT / 2, DUCK_TRANSITION_SPEED = 0.04;
            let animationState = { jumpStartHeight: 0, duckStartHeight: 0, duckStartScale: 1.0 };
            let firstObstacleSpawned = false;
            let backgroundMusic, isMuted = false;
            
            // Sound effects
            let jumpSound, duckSound, collisionSound;
            
            // Sound manager for handling all game sounds
            const soundManager = {
                init() {
                    // Create Audio objects for each sound effect
                    jumpSound = new Audio('JumpSound.mp3');
                    duckSound = new Audio('DuckSound.mp3');
                    collisionSound = new Audio('Light Impact Sound.mp3');
                    
                    // Preload sounds
                    jumpSound.load();
                    duckSound.load();
                    collisionSound.load();
                    
                    // Set properties
                    jumpSound.volume = 0.5;
                    duckSound.volume = 0.5;
                    collisionSound.volume = 0.6;
                },
                
                play(sound) {
                    if (isMuted) return;
                    
                    // Reset sound to beginning if it's already playing
                    sound.pause();
                    sound.currentTime = 0;
                    
                    // Play the sound with a catch for browsers that block autoplay
                    sound.play().catch(e => {
                        console.log("Sound play prevented:", e);
                    });
                },
                
                playJump() {
                    this.play(jumpSound);
                },
                
                playDuck() {
                    this.play(duckSound);
                },
                
                playCollision() {
                    this.play(collisionSound);
                },
                
                setMute(muted) {
                    // This function is called when the mute button is toggled
                    jumpSound.muted = muted;
                    duckSound.muted = muted;
                    collisionSound.muted = muted;
                }
            };

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 1, -5);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.getElementById('game-container').appendChild(renderer.domElement);
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                const groundGeometry = new THREE.BoxGeometry(20, 0.5, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.position.y = -0.25;
                ground.position.z = -20;
                ground.receiveShadow = true;
                scene.add(ground);
                createPlayer();
                updateControlsText();
                updateLivesDisplay();
                updateScoreDisplay();
                
                // Initialize sound manager
                soundManager.init();
                
                inputsActive = true;
                setupEventListeners();
                for (let i = 0; i < 5; i++) renderer.render(scene, camera);
                animate();
            }

            function createPlayer() {
                const playerGeometry = new THREE.BoxGeometry(PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_DEPTH);
                const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF });
                player = new THREE.Mesh(playerGeometry, playerMaterial);
                player.position.y = DEFAULT_Y;
                player.position.z = 0;
                player.castShadow = true;
                scene.add(player);
            }

            function setupEventListeners() {
                const jumpFunction = () => { if (!isJumping) jump(); };
                const duckFunction = () => { if (!isInDuckAnimation && !isJumping) duck(); };
                window.addEventListener('keydown', (event) => {
                    event.preventDefault();
                    if (event.code === 'KeyP') { togglePause(); return; }
                    if ((!gameRunning || gamePaused) && !countdownActive) return;
                    if (event.code === 'Space' || event.code === 'ArrowUp') jumpFunction();
                    else if (event.code === 'ArrowDown' || event.code === 'KeyS') duckFunction();
                });
                const gameContainer = document.getElementById('game-container');
                gameContainer.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if ((!gameRunning || gamePaused) && !countdownActive) return;
                    const touch = event.touches[0];
                    const containerHeight = gameContainer.clientHeight;
                    if (touch.clientY < containerHeight / 2) jumpFunction();
                    else duckFunction();
                });
                const startButton = document.getElementById('start-button');
                startButton.addEventListener('click', startGame);
                startButton.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    console.log("Start button touched on mobile");
                    startGame();
                });
                const restartButton = document.getElementById('restart-button');
                restartButton.addEventListener('click', restartGame);
                restartButton.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    console.log("Restart button touched on mobile");
                    restartGame();
                });
                document.getElementById('resume-button').addEventListener('click', togglePause);
                
                // Set up mute button
                const muteButton = document.getElementById('mute-button');
                muteButton.addEventListener('click', toggleMute);
                muteButton.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    toggleMute();
                });
                
                // Initialize background music
                backgroundMusic = document.getElementById('background-music');
                backgroundMusic.volume = 0.5;  // Set initial volume to 50%
                
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        console.log("Tab reactivated, reloading to main menu");
                        window.location.reload();
                    }
                });
            }

            function toggleMute() {
                isMuted = !isMuted;
                const muteButton = document.getElementById('mute-button');
                
                if (isMuted) {
                    backgroundMusic.pause();
                    muteButton.textContent = '🔇';
                } else {
                    backgroundMusic.play().catch(e => {
                        console.log("Auto-play prevented. User must interact with the page first.");
                    });
                    muteButton.textContent = '🔊';
                }
                
                // Update sound effects mute state
                soundManager.setMute(isMuted);
            }

            function updateControlsText() {
                const controlsInfo = document.getElementById('controls-info');
                if (controlsInfo) {
                    controlsInfo.innerHTML = `
                        <p>Controls:</p>
                        <p>Jump: SPACE / UP ARROW / Tap top half</p>
                        <p>Duck: DOWN ARROW / Tap bottom half</p>
                        <p>Pause: P</p>
                    `;
                }
                const instructions = document.getElementById('instructions');
                if (instructions) {
                    instructions.innerHTML = `
                        Jump: SPACE / UP ARROW / Tap top half<br>
                        Duck: DOWN ARROW / Tap bottom half<br>
                        Pause: P
                    `;
                }
            }

            function startGame() {
                console.log("startGame() called");
                document.getElementById('start-screen').style.display = 'none';
                score = 0;
                updateScoreDisplay();
                lives = 3;
                updateLivesDisplay();
                obstacleSpeed = INITIAL_OBSTACLE_SPEED;
                baseDifficulty = 1.0;
                difficultyFactor = 1.0;
                nextObstacleDistance = EARLY_GAME_MIN_SPACING + 
                    (Math.random() * (EARLY_GAME_MAX_SPACING - EARLY_GAME_MIN_SPACING));
                minObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE;
                player.position.y = DEFAULT_Y;
                player.scale.y = 1.0;
                player.visible = true;
                isDownKeyPressed = false;
                isJumping = false;
                isDucking = false;
                isInDuckAnimation = false;
                duckAnimationPhase = 0;
                isInvincible = false;
                for (const obstacle of obstacles) scene.remove(obstacle);
                obstacles = [];
                document.getElementById('game-container').focus();
                renderer.render(scene, camera);
                
                // Play background music if not muted
                if (!isMuted) {
                    backgroundMusic.play().catch(e => {
                        console.log("Auto-play prevented. User must interact with the page first.");
                    });
                }
                
                startCountdown(() => {
                    console.log("Countdown complete, starting game");
                    gameStarted = true;
                    gameRunning = true;
                    firstObstacleSpawned = false;
                    lastObstacleTime = Date.now() / 1000;
                    setTimeout(() => {
                        const firstObstacleType = Math.random() > 0.5 ? 1 : 0;
                        createObstacle(firstObstacleType);
                    }, 500);
                });
            }

            function jump() {
                if (isJumping) return;
                animationState.jumpStartHeight = player.position.y;
                if (isDucking || isInDuckAnimation) {
                    if (duckAnimationId) cancelAnimationFrame(duckAnimationId);
                    isDucking = false;
                    isInDuckAnimation = false;
                    duckAnimationPhase = 0;
                }
                isJumping = true;
                jumpProgress = 0;
                
                // Play jump sound
                soundManager.playJump();
                
                const scaledJumpDuration = JUMP_DURATION / Math.sqrt(difficultyFactor);
                const jumpStart = Date.now();
                function jumpAnimation() {
                    if (gamePaused) {
                        jumpAnimationId = requestAnimationFrame(jumpAnimation);
                        return;
                    }
                    const jumpTime = Date.now() - jumpStart;
                    jumpProgress = jumpTime / scaledJumpDuration;
                    if (jumpProgress < 1) {
                        jumpHeight = Math.sin(jumpProgress * Math.PI) * JUMP_HEIGHT;
                        const blendFactor = Math.min(1, jumpProgress * 3);
                        player.position.y = (1 - blendFactor) * animationState.jumpStartHeight + 
                                            blendFactor * (DEFAULT_Y + jumpHeight);
                        if (player.scale.y < 1.0) player.scale.y = Math.min(1.0, player.scale.y + 0.1);
                        jumpAnimationId = requestAnimationFrame(jumpAnimation);
                    } else {
                        player.position.y = DEFAULT_Y;
                        player.scale.y = 1.0;
                        isJumping = false;
                        jumpHeight = 0;
                        jumpAnimationId = null;
                        if (isDownKeyPressed) duck();
                    }
                }
                jumpAnimation();
            }

            function duck() {
                if (isJumping || isInDuckAnimation) return;
                animationState.duckStartHeight = player.position.y;
                animationState.duckStartScale = player.scale.y;
                isInDuckAnimation = true;
                isDucking = true;
                duckAnimationPhase = 1;
                duckProgress = 0;
                duckHeight = animationState.duckStartScale;
                
                // Play duck sound
                soundManager.playDuck();
                
                const scaledDifficulty = Math.min(difficultyFactor, score / MAX_DIFFICULTY_SCORE * 3 + 1);
                const scaledDuckDuration = DUCK_DURATION / Math.sqrt(scaledDifficulty);
                const duckStart = Date.now();
                if (duckAnimationId) cancelAnimationFrame(duckAnimationId);
                function duckAnimation() {
                    if (gamePaused) {
                        duckAnimationId = requestAnimationFrame(duckAnimation);
                        return;
                    }
                    const now = Date.now();
                    const elapsedTime = now - duckStart;
                    duckProgress = elapsedTime / scaledDuckDuration;
                    if (duckProgress >= 1) {
                        player.scale.y = 1.0;
                        player.position.y = DEFAULT_Y;
                        isInDuckAnimation = false;
                        isDucking = false;
                        duckAnimationPhase = 0;
                        duckAnimationId = null;
                        return;
                    }
                    const downThreshold = DUCK_DOWN_PERCENT;
                    const holdThreshold = downThreshold + DUCK_HOLD_PERCENT;
                    if (duckProgress < downThreshold) {
                        duckAnimationPhase = 1;
                        const phaseProgress = duckProgress / downThreshold;
                        const startScale = animationState.duckStartScale;
                        duckHeight = startScale - ((startScale - 0.5) * phaseProgress);
                    } else if (duckProgress < holdThreshold) {
                        duckAnimationPhase = 2;
                        duckHeight = 0.5;
                    } else {
                        duckAnimationPhase = 3;
                        const phaseProgress = (duckProgress - holdThreshold) / DUCK_UP_PERCENT;
                        duckHeight = 0.5 + (0.5 * phaseProgress);
                        isDucking = duckHeight < 0.75;
                    }
                    player.scale.y = duckHeight;
                    player.position.y = DEFAULT_Y * duckHeight;
                    duckAnimationId = requestAnimationFrame(duckAnimation);
                }
                duckAnimation();
            }

            function createObstacle(type) {
                let obstacleGeometry, obstacleMaterial;
                firstObstacleSpawned = true;
                if (type === 0) {
                    obstacleGeometry = new THREE.BoxGeometry(1, 0.5, 0.5);
                    obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
                } else {
                    obstacleGeometry = new THREE.Group();
                    const bodyGeo = new THREE.BoxGeometry(1, 0.8, 0.7);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    body.position.y = 0.2;
                    obstacleGeometry.add(body);
                    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    const headMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                    const head = new THREE.Mesh(headGeo, headMat);
                    head.position.set(0, 0.8, 0.2);
                    obstacleGeometry.add(head);
                    const billGeo = new THREE.BoxGeometry(0.3, 0.2, 0.3);
                    const billMat = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
                    const bill = new THREE.Mesh(billGeo, billMat);
                    bill.position.set(0, 0.8, 0.5);
                    obstacleGeometry.add(bill);
                    obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                }
                let obstacle = type === 0 ? new THREE.Mesh(obstacleGeometry, obstacleMaterial) : obstacleGeometry;
                obstacle.position.y = type === 0 ? 0.25 : 1.0;
                obstacle.position.z = -50;
                obstacle.castShadow = true;
                obstacle.userData = { type: type, passed: false, hit: false };
                scene.add(obstacle);
                obstacles.push(obstacle);
            }

            function checkCollisions() {
                if (isInvincible) return;
                const playerBoundingBox = new THREE.Box3().setFromObject(player);
                for (const obstacle of obstacles) {
                    if (obstacle.position.z > 2 || obstacle.userData.hit) continue;
                    const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacle);
                    if (obstacle.userData.type === 0) {
                        if (playerBoundingBox.intersectsBox(obstacleBoundingBox) && !isJumping) {
                            obstacle.userData.hit = true;
                            handleCollision();
                            break;
                        }
                    } else {
                        if (playerBoundingBox.intersectsBox(obstacleBoundingBox) && !isDucking) {
                            obstacle.userData.hit = true;
                            handleCollision();
                            break;
                        }
                    }
                }
            }

            function handleCollision() {
                lives--;
                
                // Play collision sound
                soundManager.playCollision();
                
                updateLivesDisplay();
                if (lives <= 0) gameOver();
                else {
                    isInvincible = true;
                    let blinkCount = 0;
                    const blinkInterval = setInterval(() => {
                        player.visible = !player.visible;
                        blinkCount++;
                        if (blinkCount >= 10) {
                            clearInterval(blinkInterval);
                            player.visible = true;
                            isInvincible = false;
                        }
                    }, 200);
                }
            }

            function updateScoreForPassedObstacles() {
                for (const obstacle of obstacles) {
                    if (obstacle.position.z > 0 && !obstacle.userData.passed && !obstacle.userData.hit) {
                        obstacle.userData.passed = true;
                        score++;
                        updateScoreDisplay();
                        if (obstacle.userData.type === 1) {
                            obstacle.traverse((child) => {
                                if (child.isMesh) {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.3;
                                }
                            });
                        } else {
                            obstacle.material.transparent = true;
                            obstacle.material.opacity = 0.3;
                        }
                        updateDifficulty();
                    }
                }
            }

            function updateDifficulty() {
                if (score <= MAX_DIFFICULTY_SCORE) {
                    const progressToMax = score / MAX_DIFFICULTY_SCORE;
                    const speedProgress = Math.pow(progressToMax, score < 30 ? 0.8 : 1.2);
                    obstacleSpeed = INITIAL_OBSTACLE_SPEED + 
                        (MAX_OBSTACLE_SPEED - INITIAL_OBSTACLE_SPEED) * speedProgress;
                    if (score <= EARLY_GAME_THRESHOLD) {
                        nextObstacleDistance = EARLY_GAME_MIN_SPACING + 
                            (Math.random() * (EARLY_GAME_MAX_SPACING - EARLY_GAME_MIN_SPACING));
                    } else if (score < CHALLENGE_THRESHOLD) {
                        const baseSpacing = EARLY_GAME_MIN_SPACING - (0.3 * (score - EARLY_GAME_THRESHOLD) / 15);
                        nextObstacleDistance = Math.random() < 0.3 ? 
                            Math.max(0.7, baseSpacing - 0.4 + (Math.random() * 0.3)) : 
                            baseSpacing + (Math.random() * 0.3);
                    } else {
                        if (inCooldownPhase) {
                            const currentTime = Date.now() / 1000;
                            if (currentTime >= cooldownEndTime) {
                                inCooldownPhase = false;
                                if (Math.random() < 0.7) setupBurst();
                                else generateObstaclePattern();
                            } else nextObstacleDistance = 1.5 + (Math.random() * 0.3);
                        } else if (burstMode) {
                            const burstProgress = burstCount / maxBurstCount;
                            const baseSpacing = 0.65 - (0.2 * Math.sin(burstProgress * Math.PI));
                            nextObstacleDistance = Math.max(MIN_OBSTACLE_DISTANCE_AT_MAX, 
                                baseSpacing + (Math.random() * 0.15) - 0.075);
                            burstCount++;
                            if (burstCount >= maxBurstCount) {
                                burstMode = false;
                                startCooldown();
                            }
                        } else if (patternMode) {
                            if (currentPatternIndex >= currentPattern.length) {
                                patternMode = false;
                                startCooldown();
                            }
                        } else {
                            const challengeRoll = Math.random();
                            if (challengeRoll < 0.7) setupBurst();
                            else if (challengeRoll < 0.95) generateObstaclePattern();
                            else startCooldown();
                        }
                    }
                }
            }

            function setupBurst() {
                burstMode = true;
                burstCount = 0;
                const baseBurstSize = 3;
                const extraBursts = Math.min(5, Math.floor((score - CHALLENGE_THRESHOLD) / 20));
                maxBurstCount = baseBurstSize + extraBursts;
                if (Math.random() < 0.6) maxBurstCount += Math.floor(Math.random() * 3);
                nextObstacleDistance = 0.8 + (Math.random() * 0.2);
            }

            function startCooldown() {
                inCooldownPhase = true;
                const cooldownDuration = 1.0 + (Math.random() * 1.0);
                cooldownEndTime = (Date.now() / 1000) + cooldownDuration;
                nextObstacleDistance = cooldownDuration;
            }

            function generateObstaclePattern() {
                patternMode = true;
                currentPatternIndex = 0;
                const patternLength = Math.floor(Math.random() * 4) + 3;
                currentPattern = [];
                const basePatternSpacing = Math.max(
                    MIN_OBSTACLE_DISTANCE_AT_MAX,
                    0.85 - (0.4 * Math.min(1, (score - CHALLENGE_THRESHOLD) / (MAX_DIFFICULTY_SCORE - CHALLENGE_THRESHOLD)))
                );
                nextObstacleDistance = basePatternSpacing + (Math.random() * 0.2);
                currentPattern.push(Math.random() > 0.5 ? 1 : 0);
                for (let i = 1; i < patternLength; i++) {
                    const prevType = currentPattern[i-1];
                    if (score > 80 && Math.random() < 0.4) currentPattern.push(prevType);
                    else currentPattern.push(1 - prevType);
                    if (i < patternLength - 1) {
                        currentPattern[i-1] = {
                            type: currentPattern[i-1], 
                            spacing: basePatternSpacing * (0.9 + (Math.random() * 0.2))
                        };
                    } else {
                        currentPattern[i-1] = {
                            type: currentPattern[i-1],
                            spacing: basePatternSpacing * (0.9 + (Math.random() * 0.2))
                        };
                    }
                }
                currentPattern[patternLength-1] = {
                    type: currentPattern[patternLength-1],
                    spacing: basePatternSpacing * (0.9 + (Math.random() * 0.2))
                };
            }

            function updateScoreDisplay() {
                document.getElementById('score-display').textContent = `Score: ${score}`;
            }

            function updateLivesDisplay() {
                const livesContainer = document.querySelector('.lives-container');
                livesContainer.innerHTML = '';
                for (let i = 0; i < lives; i++) {
                    const lifeCircle = document.createElement('div');
                    lifeCircle.className = 'life-circle';
                    livesContainer.appendChild(lifeCircle);
                }
            }

            function togglePause() {
                if (!gameStarted || !gameRunning) return;
                gamePaused = !gamePaused;
                document.getElementById('pause-screen').style.display = gamePaused ? 'flex' : 'none';
                
                // Pause/resume music with game
                if (gamePaused && !isMuted) {
                    backgroundMusic.pause();
                } else if (!gamePaused && !isMuted) {
                    backgroundMusic.play().catch(e => {
                        console.log("Auto-play prevented. User must interact with the page first.");
                    });
                }
                
                if (!gamePaused) lastObstacleTime = Date.now() / 1000;
            }

            function gameOver() {
                gameRunning = false;
                firstObstacleSpawned = false;
                if (jumpAnimationId) cancelAnimationFrame(jumpAnimationId);
                if (duckAnimationId) cancelAnimationFrame(duckAnimationId);
                document.getElementById('lives-display').style.display = 'none';
                document.getElementById('final-score').textContent = `Final Score: ${score}`;
                document.getElementById('game-over').style.display = 'block';
                
                // Pause music on game over
                backgroundMusic.pause();
            }

            function restartGame() {
                console.log("restartGame() called");
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('pause-screen').style.display = 'none';
                document.getElementById('lives-display').style.display = 'flex';
                score = 0;
                updateScoreDisplay();
                lives = 3;
                updateLivesDisplay();
                obstacleSpeed = INITIAL_OBSTACLE_SPEED;
                baseDifficulty = 1.0;
                difficultyFactor = 1.0;
                nextObstacleDistance = EARLY_GAME_MIN_SPACING + 
                    (Math.random() * (EARLY_GAME_MAX_SPACING - EARLY_GAME_MIN_SPACING));
                minObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE;
                patternMode = false;
                currentPattern = [];
                currentPatternIndex = 0;
                burstMode = false;
                burstCount = 0;
                maxBurstCount = 0;
                inCooldownPhase = false;
                player.position.y = DEFAULT_Y;
                player.scale.y = 1.0;
                player.visible = true;
                isDownKeyPressed = false;
                isJumping = false;
                isDucking = false;
                isInDuckAnimation = false;
                duckAnimationPhase = 0;
                isInvincible = false;
                if (jumpAnimationId) cancelAnimationFrame(jumpAnimationId);
                if (duckAnimationId) cancelAnimationFrame(duckAnimationId);
                for (const obstacle of obstacles) scene.remove(obstacle);
                obstacles = [];
                inputsActive = true;
                renderer.render(scene, camera);
                
                // Play background music if not muted
                if (!isMuted) {
                    backgroundMusic.play().catch(e => {
                        console.log("Auto-play prevented. User must interact with the page first.");
                    });
                }
                
                startCountdown(() => {
                    console.log("Countdown complete, starting game");
                    gameStarted = true;
                    gameRunning = true;
                    firstObstacleSpawned = false;
                    lastObstacleTime = Date.now() / 1000;
                    setTimeout(() => {
                        const firstObstacleType = Math.random() > 0.5 ? 1 : 0;
                        createObstacle(firstObstacleType);
                    }, 500);
                });
            }

            function startCountdown(callback) {
                console.log("startCountdown() called");
                const countdownElement = document.getElementById('countdown');
                const readyTextElement = document.getElementById('ready-text');
                countdownValue = 3;
                countdownActive = true;
                inputsActive = true;
                for (let i = 0; i < 5; i++) renderer.render(scene, camera);
                readyTextElement.style.display = 'block';
                countdownElement.style.display = 'block';
                countdownElement.textContent = countdownValue;
                countdownElement.classList.remove('animate');
                const countdownInterval = setInterval(() => {
                    countdownElement.classList.add('animate');
                    setTimeout(() => {
                        countdownValue--;
                        if (countdownValue > 0) {
                            countdownElement.textContent = countdownValue;
                            countdownElement.classList.remove('animate');
                            renderer.render(scene, camera);
                        } else {
                            clearInterval(countdownInterval);
                            countdownElement.style.display = 'none';
                            readyTextElement.style.display = 'none';
                            countdownActive = false;
                            renderer.render(scene, camera);
                            if (callback) callback();
                        }
                    }, 500);
                }, 1000);
            }

            function animate() {
                requestAnimationFrame(animate);
                try {
                    inputsActive = gameStarted || gameRunning || countdownActive;
                    if (gameRunning && !gamePaused) {
                        ground.position.z += obstacleSpeed;
                        if (ground.position.z > 30) ground.position.z = -20;
                        for (let i = obstacles.length - 1; i >= 0; i--) {
                            const obstacle = obstacles[i];
                            obstacle.position.z += obstacleSpeed;
                            if (obstacle.position.z > 10) {
                                scene.remove(obstacle);
                                obstacles.splice(i, 1);
                            }
                        }
                        const currentTime = Date.now() / 1000;
                        if (firstObstacleSpawned && currentTime - lastObstacleTime > nextObstacleDistance) {
                            let obstacleType;
                            if (patternMode) {
                                const patternItem = currentPattern[currentPatternIndex];
                                obstacleType = typeof patternItem === 'object' ? patternItem.type : patternItem;
                                if (typeof patternItem === 'object' && patternItem.spacing) {
                                    nextObstacleDistance = patternItem.spacing;
                                }
                                currentPatternIndex++;
                            } else {
                                obstacleType = (score > 100 && obstacles.length > 0 && Math.random() < 0.7) ?
                                    (1 - obstacles[obstacles.length - 1].userData.type) :
                                    (Math.random() > 0.5 ? 1 : 0);
                            }
                            createObstacle(obstacleType);
                            lastObstacleTime = currentTime;
                            updateDifficulty();
                        }
                        checkCollisions();
                        updateScoreForPassedObstacles();
                    }
                    renderer.render(scene, camera);
                } catch (error) {
                    console.error("Error in animation loop:", error);
                    if (gameRunning) gameOver();
                }
            }

            init();
        });
    </script>
    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">🕹️ Vibe Jam 2025</a>
</body>
</html>
