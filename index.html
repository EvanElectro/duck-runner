<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Duck Runner Game</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            outline: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }
        #score-display {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        #lives-display {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
        }
        #lives-label {
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        .lives-container {
            display: flex;
            gap: 8px;
        }
        .life-circle {
            width: 25px;
            height: 25px;
            background-color: #FF6347;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #difficulty-display {
            display: none; /* Hide difficulty display */
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #pause-button {
            display: none; /* Hide the pause button */
        }
        /* Mobile touch controls */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            z-index: 90;
            display: none; /* Hidden by default, shown on mobile */
            pointer-events: none;
        }
        .control-half {
            position: absolute;
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }
        #jump-zone {
            left: 0;
        }
        #duck-zone {
            right: 0;
        }
        .control-indicator {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
            opacity: 0.7;
        }
        .control-indicator.active {
            background-color: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%) scale(1.2);
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87CEEB, #4682B4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #start-title {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-family: Arial, sans-serif;
        }
        #start-subtitle {
            color: white;
            font-size: 18px;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        #start-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 40px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 24px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        #start-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        #controls-info {
            margin-top: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 150;
            display: none;
        }
        #pause-message {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #restart-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 5px;
        }
        /* Countdown styling */
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: white;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: none;
            font-weight: bold;
            transition: transform 0.5s ease, opacity 0.5s ease;
            opacity: 1;
            animation: pulse 0.5s infinite alternate;
        }
        #countdown.animate {
            transform: translate(-50%, -50%) scale(2);
            opacity: 0;
        }
        @keyframes pulse {
            from { text-shadow: 0 0 20px rgba(0, 0, 0, 0.8); }
            to { text-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 40px rgba(0, 255, 255, 0.6); }
        }
        /* Ready indicator */
        #ready-text {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: white;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 300;
            display: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container" tabindex="-1">
        <div id="lives-display">
            <div id="lives-label">Lives:</div>
            <div class="lives-container"></div>
        </div>
        <button id="pause-button">Pause</button>
        <div id="difficulty-display">Difficulty: 1.0x</div>
        <div id="instructions">
            <span class="keyboard-controls">SPACE/UP to jump • DOWN to duck • P to pause</span>
            <span class="mobile-controls">TAP LEFT to jump • TAP RIGHT to duck</span>
        </div>
        <div id="score-display">Score: 0</div>
        
        <div id="countdown">3</div>
        <div id="ready-text">GET READY!</div>
        
        <!-- Mobile touch controls -->
        <div id="mobile-controls">
            <div id="jump-zone" class="control-half">
                <div class="control-indicator">JUMP</div>
            </div>
            <div id="duck-zone" class="control-half">
                <div class="control-indicator">DUCK</div>
            </div>
        </div>
        
        <div id="start-screen">
            <h1 id="start-title">Duck Runner</h1>
            <p id="start-subtitle">Jump over blocks and duck under ducks in this fast-paced 3D endless runner!</p>
            <button id="start-button">Start Game</button>
            <div id="controls-info">
                <p>Controls:</p>
                <div class="keyboard-controls">SPACE or UP ARROW to jump | DOWN ARROW to duck | P to pause</div>
                <div class="mobile-controls">Tap LEFT side to jump | Tap RIGHT side to duck</div>
            </div>
        </div>
        
        <div id="pause-screen">
            <div id="pause-message">
                <h2>Game Paused</h2>
                <p>Press P or click below to resume</p>
                <button id="resume-button">Resume</button>
            </div>
        </div>
        
        <div id="game-over">
            <h2>Game Over!</h2>
            <p id="final-score">Final Score: 0</p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Wait for DOM content to be fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Fix mobile viewport height issue
            function setVHVariable() {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }
            
            // Set initially and on resize
            setVHVariable();
            window.addEventListener('resize', setVHVariable);
            
            // Detect if device is mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                             window.innerWidth < 800;
            
            // Show appropriate control instructions
            document.querySelectorAll('.keyboard-controls').forEach(el => {
                el.style.display = isMobile ? 'none' : 'block';
            });
            document.querySelectorAll('.mobile-controls').forEach(el => {
                el.style.display = isMobile ? 'block' : 'none';
            });
            
            // Show mobile controls if on mobile
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                document.getElementById('instructions').style.fontSize = '14px';
            }
            
            // Performance settings
            const LOW_PERFORMANCE_MODE = isMobile;
            const SHADOW_ENABLED = !LOW_PERFORMANCE_MODE;
            const ANIMATION_FRAME_THROTTLE = LOW_PERFORMANCE_MODE ? 2 : 1; // Only render every X frames on low-end devices
            let frameCount = 0;
            
            // Three.js variables
            let scene, camera, renderer;
            let player, ground;
            let obstacles = [];
            
            // Game state variables
            let score = 0;
            let lives = 3;
            let isJumping = false;
            let isDucking = false;
            let isInDuckAnimation = false;
            let duckAnimationPhase = 0; // 0 = not ducking, 1 = going down, 2 = holding, 3 = coming up
            let isInvincible = false;
            let gameRunning = false;
            let gameStarted = false;
            let gamePaused = false;
            let isDownKeyPressed = false;
            let jumpAnimationId = null;
            let duckAnimationId = null;
            let jumpHeight = 0;
            let jumpProgress = 0;
            let duckProgress = 0;
            let duckHeight = 1.0; // Current duck height (1.0 is normal, 0.5 is ducked)
            let DUCK_DURATION = 500; // Total duck sequence duration
            let DUCK_DOWN_PERCENT = 0.3; // 30% of time spent going down
            let DUCK_HOLD_PERCENT = 0.4; // 40% of time spent holding duck
            let DUCK_UP_PERCENT = 0.3; // 30% of time spent coming up
            let JUMP_DURATION = 500; // Faster jump duration
            
            // Difficulty scaling constants
            const MAX_DIFFICULTY_SCORE = 250; // Score at which difficulty peaks (frame-perfect inputs)
            const INITIAL_OBSTACLE_SPEED = 0.15; // Starting speed
            const MAX_OBSTACLE_SPEED = 0.6; // Maximum speed at difficulty peak
            const MAX_DIFFICULTY_FACTOR = 4.0; // Maximum difficulty multiplier
            let obstacleSpeed = INITIAL_OBSTACLE_SPEED;
            let baseDifficulty = 1.0;
            let difficultyFactor = 1.0;
            
            // Obstacle spacing parameters
            const INITIAL_MIN_OBSTACLE_DISTANCE = 2.0; // Starting distance between obstacles (in seconds)
            const MIN_OBSTACLE_DISTANCE_AT_MAX = 0.45; // Minimum distance at max difficulty (frame-perfect timing)
            const EARLY_GAME_MIN_SPACING = 1.0; // Minimum spacing in early game (0-20 score)
            const EARLY_GAME_MAX_SPACING = 1.5; // Maximum spacing in early game (0-20 score)
            const EARLY_GAME_THRESHOLD = 20; // Score threshold for early game spacing
            const MID_GAME_THRESHOLD = 50; // Score threshold for mid game spacing
            let minObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE;
            let lastObstacleTime = 0;
            let nextObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE; // Variable to store next obstacle spacing
            
            // Pattern generation variables
            let patternMode = false;
            let currentPatternIndex = 0;
            let currentPattern = [];
            
            // Burst mode variables
            let burstMode = false;
            let burstCount = 0;
            let maxBurstCount = 0;
            let postBurstPause = false;
            let pauseEndTime = 0;
            
            // Add flag to track input readiness
            let inputsActive = true;
            
            // Countdown state
            let countdownActive = false;
            let countdownValue = 3;
            
            // Player properties
            const PLAYER_HEIGHT = 1.0;
            const PLAYER_WIDTH = 0.5;
            const PLAYER_DEPTH = 0.5;
            const JUMP_HEIGHT = 1.5;
            const DUCK_HEIGHT = 0.5;
            const DEFAULT_Y = PLAYER_HEIGHT / 2;
            const DUCK_TRANSITION_SPEED = 0.04; // Speed of duck animation transitions
            
            // Animation transition helpers
            let animationState = {
                jumpStartHeight: 0,
                duckStartHeight: 0,
                duckStartScale: 1.0
            };
            
            // Add a flag to track if the first obstacle has spawned
            let firstObstacleSpawned = false;
            
            // Initialize the game
            function init() {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue background
                
                // Create camera (3rd person view)
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 1, -5);
                
                // Create renderer with appropriate settings
                renderer = new THREE.WebGLRenderer({ 
                    antialias: !LOW_PERFORMANCE_MODE,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, LOW_PERFORMANCE_MODE ? 1 : 2));
                renderer.shadowMap.enabled = SHADOW_ENABLED;
                
                // Add renderer to DOM
                const container = document.getElementById('game-container');
                container.appendChild(renderer.domElement);
                
                // Create lighting - simplified for mobile
                const ambientLight = new THREE.AmbientLight(0xffffff, LOW_PERFORMANCE_MODE ? 0.8 : 0.6);
                scene.add(ambientLight);
                
                if (!LOW_PERFORMANCE_MODE) {
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(10, 20, 10);
                    directionalLight.castShadow = true;
                    // Optimize shadow map
                    directionalLight.shadow.mapSize.width = 1024;
                    directionalLight.shadow.mapSize.height = 1024;
                    directionalLight.shadow.camera.near = 0.5;
                    directionalLight.shadow.camera.far = 50;
                    scene.add(directionalLight);
                } else {
                    // Simpler light for mobile
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(10, 20, 10);
                    directionalLight.castShadow = false;
                    scene.add(directionalLight);
                }
                
                // Create ground with optimized geometry
                const groundGeometry = new THREE.BoxGeometry(20, 0.5, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.position.y = -0.25;
                ground.position.z = -20;
                ground.receiveShadow = SHADOW_ENABLED;
                scene.add(ground);
                
                // Create player
                createPlayer();
                
                // Update UI text to reflect control options
                updateControlsText();
                
                // Initialize UI
                updateLivesDisplay();
                updateScoreDisplay();
                
                // Ensure inputs are active from the very beginning
                inputsActive = true;
                
                // Setup event listeners
                setupEventListeners();
                
                // Initial render
                renderer.render(scene, camera);
                
                // Start animation loop
                animate();
                
                // Force full screen on mobile
                if (isMobile) {
                    tryEnterFullscreen();
                }
            }
            
            // Attempt to enter fullscreen mode (especially helpful on mobile)
            function tryEnterFullscreen() {
                const gameContainer = document.getElementById('game-container');
                
                if (gameContainer.requestFullscreen) {
                    gameContainer.requestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
                } else if (gameContainer.webkitRequestFullscreen) {
                    gameContainer.webkitRequestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
                } else if (gameContainer.mozRequestFullScreen) {
                    gameContainer.mozRequestFullScreen().catch(err => console.log('Fullscreen request failed:', err));
                } else if (gameContainer.msRequestFullscreen) {
                    gameContainer.msRequestFullscreen().catch(err => console.log('Fullscreen request failed:', err));
                }
            }
            
            // Function to update the controls text in the UI
            function updateControlsText() {
                // Update the controls info in the start screen
                const controlsInfo = document.getElementById('controls-info');
                if (controlsInfo) {
                    controlsInfo.innerHTML = `
                        <p>Controls:</p>
                        <div class="keyboard-controls">SPACE or UP ARROW to jump | DOWN ARROW to duck | P to pause</div>
                        <div class="mobile-controls">Tap LEFT side to jump | Tap RIGHT side to duck</div>
                    `;
                }
                
                // Also update the in-game instructions
                const instructions = document.getElementById('instructions');
                if (instructions) {
                    instructions.innerHTML = `
                        Press SPACE or UP ARROW to jump<br>
                        Press DOWN ARROW to duck<br>
                        Press P to pause
                    `;
                }
            }
            
            // Create player character
            function createPlayer() {
                const playerGeometry = new THREE.BoxGeometry(PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_DEPTH);
                const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x1E90FF });
                player = new THREE.Mesh(playerGeometry, playerMaterial);
                player.position.y = DEFAULT_Y;
                player.position.z = 0;
                player.castShadow = true;
                scene.add(player);
            }
            
            // Setup keyboard event listeners
            function setupEventListeners() {
                // Pre-bind functions for faster response
                const jumpFunction = () => {
                    if (!isJumping && (gameRunning || countdownActive) && !gamePaused) jump();
                };
                
                const duckFunction = () => {
                    isDownKeyPressed = true;
                    if (!isInDuckAnimation && !isJumping && (gameRunning || countdownActive) && !gamePaused) duck();
                };
                
                const keyReleasedFunction = () => {
                    isDownKeyPressed = false;
                };
                
                // Use window for key events to ensure consistent registration
                window.addEventListener('keydown', (event) => {
                    if (event.repeat) return; // Prevent key repeat
                    
                    if (event.code === 'KeyP') {
                        togglePause();
                        event.preventDefault();
                        return;
                    }
                    
                    // Always allow input during countdown or active game
                    if ((!gameRunning || gamePaused) && !countdownActive) {
                        return;
                    }
                    
                    // Use pre-bound functions for faster response
                    if (event.code === 'Space' || event.code === 'ArrowUp') {
                        jumpFunction();
                        event.preventDefault();
                    } else if (event.code === 'ArrowDown' || event.code === 'KeyS') {
                        duckFunction();
                        event.preventDefault();
                    }
                });
                
                window.addEventListener('keyup', (event) => {
                    if (event.code === 'ArrowDown' || event.code === 'KeyS') {
                        keyReleasedFunction();
                        event.preventDefault();
                    }
                });
                
                // Enhanced touch controls for mobile users
                const jumpZone = document.getElementById('jump-zone');
                const duckZone = document.getElementById('duck-zone');
                const jumpIndicator = jumpZone.querySelector('.control-indicator');
                const duckIndicator = duckZone.querySelector('.control-indicator');
                
                // Jump zone
                jumpZone.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    jumpIndicator.classList.add('active');
                    
                    // Only allow jump during countdown or active game
                    if ((gameRunning || countdownActive) && !gamePaused) {
                        jumpFunction();
                    } else if (!gameStarted) {
                        // Start game if tapping on start screen
                        startGame();
                    }
                });
                
                jumpZone.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    jumpIndicator.classList.remove('active');
                });
                
                // Duck zone
                duckZone.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    duckIndicator.classList.add('active');
                    
                    // Only allow duck during countdown or active game
                    if ((gameRunning || countdownActive) && !gamePaused) {
                        duckFunction();
                    } else if (!gameStarted) {
                        // Start game if tapping on start screen
                        startGame();
                    }
                });
                
                duckZone.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    duckIndicator.classList.remove('active');
                    keyReleasedFunction();
                });
                
                // Add fallback for entire container (in case the zones aren't working)
                const gameContainer = document.getElementById('game-container');
                
                gameContainer.addEventListener('touchstart', (event) => {
                    // Prevent default browser behavior
                    event.preventDefault();
                    
                    // If specific zones didn't capture the event
                    if (event.target === gameContainer || event.target === renderer.domElement) {
                        // Always allow input during countdown or active game
                        if ((!gameRunning || gamePaused) && !countdownActive) {
                            if (!gameStarted) {
                                startGame();
                            }
                            return;
                        }
                        
                        const touch = event.touches[0];
                        const containerWidth = gameContainer.clientWidth;
                        
                        if (touch.clientX < containerWidth / 2) {
                            // Left half = jump
                            jumpIndicator.classList.add('active');
                            jumpFunction();
                        } else {
                            // Right half = duck
                            duckIndicator.classList.add('active');
                            duckFunction();
                        }
                    }
                });
                
                gameContainer.addEventListener('touchend', (event) => {
                    // If specific zones didn't capture the event
                    if (event.target === gameContainer || event.target === renderer.domElement) {
                        jumpIndicator.classList.remove('active');
                        duckIndicator.classList.remove('active');
                        keyReleasedFunction();
                    }
                    event.preventDefault();
                });
                
                // Add click event for start button
                document.getElementById('start-button').addEventListener('click', (e) => {
                    e.preventDefault();
                    startGame();
                    
                    // Try to enter fullscreen on start button click (mobile friendly)
                    if (isMobile) {
                        setTimeout(tryEnterFullscreen, 100);
                    }
                });
                
                // Add click event for resume button
                document.getElementById('resume-button').addEventListener('click', togglePause);
                
                // Add click event for restart button
                document.getElementById('restart-button').addEventListener('click', restartGame);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    // Update viewport height variable
                    setVHVariable();
                    
                    // Update camera and renderer
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Handle visibility change for pause
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && gameRunning && !gamePaused) {
                        togglePause();
                    }
                });
            }
            
            // Function to ensure input readiness after game state changes
            function ensureInputReadiness() {
                // Force focus on game container
                document.getElementById('game-container').focus();
                
                // Reset key state variables to ensure no stuck inputs
                isDownKeyPressed = false;
                isJumping = false;
                isDucking = false;
                isInDuckAnimation = false;
                duckAnimationPhase = 0;
                isInvincible = false;
                
                // Clear any lingering animation frames
                if (jumpAnimationId) {
                    cancelAnimationFrame(jumpAnimationId);
                    jumpAnimationId = null;
                }
                if (duckAnimationId) {
                    cancelAnimationFrame(duckAnimationId);
                    duckAnimationId = null;
                }
                
                // Reset player position and scale
                player.position.y = DEFAULT_Y;
                player.scale.y = 1.0;
                
                // Ensure player is visible (in case it was in the middle of a blink)
                player.visible = true;
                
                // Immediately render a frame to ensure visual state is consistent with game state
                renderer.render(scene, camera);
                
                console.log("Input system ready");
            }
            
            // Function to start the countdown with smoother animation
            function startCountdown(callback) {
                const countdownElement = document.getElementById('countdown');
                const readyTextElement = document.getElementById('ready-text');
                countdownValue = 3;
                countdownActive = true;
                
                // Make player responsive to inputs immediately - even before countdown
                inputsActive = true;
                ensureInputReadiness();
                
                // Show the ready text
                readyTextElement.style.display = 'block';
                
                // Show the countdown element
                countdownElement.style.display = 'block';
                countdownElement.textContent = countdownValue;
                countdownElement.classList.remove('animate');
                
                // Force focus on game container
                document.getElementById('game-container').focus();
                
                // Pre-render to show countdown immediately
                renderer.render(scene, camera);
                
                // Play animation and decrement counter every second
                const countdownInterval = setInterval(() => {
                    countdownElement.classList.add('animate');
                    
                    // After animation completes, update the number
                    setTimeout(() => {
                        countdownValue--;
                        
                        if (countdownValue > 0) {
                            // Continue countdown
                            countdownElement.textContent = countdownValue;
                            countdownElement.classList.remove('animate');
                            
                            // Force render to ensure player responsiveness during countdown
                            renderer.render(scene, camera);
                        } else {
                            // Countdown complete
                            clearInterval(countdownInterval);
                            countdownElement.style.display = 'none';
                            readyTextElement.style.display = 'none';
                            countdownActive = false;
                            
                            // Ensure one more render before starting the game
                            renderer.render(scene, camera);
                            
                            // Execute callback when countdown is complete
                            if (callback) callback();
                        }
                    }, 500);
                }, 1000);
            }
            
            // Function to start the game
            function startGame() {
                // Try to enter fullscreen mode on mobile
                if (isMobile) {
                    tryEnterFullscreen();
                }
                
                // Hide the start screen immediately
                document.getElementById('start-screen').style.display = 'none';
                
                // Reset game state
                score = 0;
                updateScoreDisplay();
                lives = 3;
                updateLivesDisplay();
                obstacleSpeed = INITIAL_OBSTACLE_SPEED;
                baseDifficulty = 1.0;
                difficultyFactor = 1.0;
                
                // Set initial obstacle spacing
                nextObstacleDistance = EARLY_GAME_MIN_SPACING + 
                                     (Math.random() * (EARLY_GAME_MAX_SPACING - EARLY_GAME_MIN_SPACING));
                minObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE;
                
                // Reset player state
                player.position.y = DEFAULT_Y;
                player.scale.y = 1.0;
                player.visible = true;
                
                // Reset input state
                isDownKeyPressed = false;
                isJumping = false;
                isDucking = false;
                isInDuckAnimation = false;
                duckAnimationPhase = 0;
                isInvincible = false;
                
                // Make player responsive even during countdown
                inputsActive = true;
                
                // Clean up any existing obstacles
                for (const obstacle of obstacles) {
                    scene.remove(obstacle);
                }
                obstacles = [];
                
                // Force focus on the game container
                document.getElementById('game-container').focus();
                
                // Render initial state to show changes immediately
                renderer.render(scene, camera);
                
                // Add slight delay before countdown to ensure UI is updated
                setTimeout(() => {
                    // Start countdown and begin game after countdown
                    startCountdown(() => {
                        // Set game state variables after countdown
                        gameStarted = true;
                        gameRunning = true;
                        firstObstacleSpawned = false;
                        
                        // Set last obstacle time
                        lastObstacleTime = Date.now() / 1000;
                        
                        // Create first obstacle faster (after 1 second)
                        setTimeout(() => {
                            // Choose a random obstacle type for the first one
                            const firstObstacleType = Math.random() > 0.5 ? 1 : 0;
                            createObstacle(firstObstacleType);
                        }, 1000);
                    });
                }, 100);
            }
            
            // Player jump function with adaptive duration based on game speed
            function jump() {
                if (isJumping) return;
                
                // Capture current state for smooth transition
                animationState.jumpStartHeight = player.position.y;
                
                // Force the player to stand up if ducking when jump is initiated
                if (isDucking || isInDuckAnimation) {
                    // Cancel any ongoing duck animation
                    if (duckAnimationId) {
                        cancelAnimationFrame(duckAnimationId);
                        duckAnimationId = null;
                    }
                    
                    // Reset duck state
                    isDucking = false;
                    isInDuckAnimation = false;
                    duckAnimationPhase = 0;
                }
                
                isJumping = true;
                jumpProgress = 0;
                
                // Adaptive jump duration that scales with game speed
                // As the game gets faster, jumps become quicker
                const scaledJumpDuration = JUMP_DURATION / Math.sqrt(difficultyFactor);
                
                const jumpStart = Date.now();
                
                function jumpAnimation() {
                    if (gamePaused) {
                        // Store the current animation frame ID to cancel when game is resumed
                        jumpAnimationId = requestAnimationFrame(jumpAnimation);
                        return;
                    }
                    
                    const jumpTime = Date.now() - jumpStart;
                    jumpProgress = jumpTime / scaledJumpDuration;
                    
                    if (jumpProgress < 1) {
                        // Parabolic jump trajectory with smooth transition from current height
                        jumpHeight = Math.sin(jumpProgress * Math.PI) * JUMP_HEIGHT;
                        
                        // Smooth transition: start from current height and blend to parabola
                        const blendFactor = Math.min(1, jumpProgress * 3); // Fast blend to parabola
                        const currentHeight = (1 - blendFactor) * animationState.jumpStartHeight + 
                                             blendFactor * (DEFAULT_Y + jumpHeight);
                        
                        player.position.y = currentHeight;
                        
                        // Also handle scaling back to normal if we were ducking
                        if (player.scale.y < 1.0) {
                            player.scale.y = Math.min(1.0, player.scale.y + 0.1);
                        }
                        
                        jumpAnimationId = requestAnimationFrame(jumpAnimation);
                    } else {
                        // End jump
                        player.position.y = DEFAULT_Y;
                        player.scale.y = 1.0;
                        isJumping = false;
                        jumpHeight = 0;
                        jumpAnimationId = null;
                        
                        // Check if down key is pressed at landing to immediately duck
                        if (isDownKeyPressed) {
                            duck();
                        }
                    }
                }
                
                jumpAnimation();
            }
            
            // Player duck function - complete animation sequence
            function duck() {
                if (isJumping || isInDuckAnimation) return; // Cannot duck while jumping or during duck animation
                
                // Store current state for smooth transition
                animationState.duckStartHeight = player.position.y;
                animationState.duckStartScale = player.scale.y;
                
                isInDuckAnimation = true;
                isDucking = true; // Initially we are ducking
                duckAnimationPhase = 1; // Going down phase
                duckProgress = 0;
                duckHeight = animationState.duckStartScale; // Start at current height
                
                // Calculate duck duration based on difficulty, peaking at MAX_DIFFICULTY
                const scaledDifficulty = Math.min(difficultyFactor, score / MAX_DIFFICULTY_SCORE * 3 + 1);
                const scaledDuckDuration = DUCK_DURATION / Math.sqrt(scaledDifficulty);
                
                const duckStart = Date.now();
                
                // Clear any previous animation to avoid conflicts
                if (duckAnimationId) {
                    cancelAnimationFrame(duckAnimationId);
                }
                
                function duckAnimation() {
                    if (gamePaused) {
                        duckAnimationId = requestAnimationFrame(duckAnimation);
                        return;
                    }
                    
                    const now = Date.now();
                    const elapsedTime = now - duckStart;
                    duckProgress = elapsedTime / scaledDuckDuration;
                    
                    // Handle animation completion
                    if (duckProgress >= 1) {
                        // Animation complete, return to normal
                        player.scale.y = 1.0;
                        player.position.y = DEFAULT_Y;
                        isInDuckAnimation = false;
                        isDucking = false;
                        duckAnimationPhase = 0;
                        duckAnimationId = null;
                        return;
                    }
                    
                    // Determine which phase of the animation we're in
                    const downThreshold = DUCK_DOWN_PERCENT;
                    const holdThreshold = downThreshold + DUCK_HOLD_PERCENT;
                    
                    if (duckProgress < downThreshold) {
                        // PHASE 1: Going down
                        duckAnimationPhase = 1;
                        
                        // Smooth transition for first phase
                        // Start from current height/scale and go to duck position
                        const phaseProgress = duckProgress / downThreshold;
                        
                        // Calculate smooth transition from start scale to target scale (0.5)
                        const startScale = animationState.duckStartScale;
                        duckHeight = startScale - ((startScale - 0.5) * phaseProgress);
                    } 
                    else if (duckProgress < holdThreshold) {
                        // PHASE 2: Holding duck
                        duckAnimationPhase = 2;
                        duckHeight = 0.5; // Fully ducked
                    } 
                    else {
                        // PHASE 3: Coming back up
                        duckAnimationPhase = 3;
                        // Normalize progress within this phase (0-1)
                        const phaseProgress = (duckProgress - holdThreshold) / DUCK_UP_PERCENT;
                        // Lerp from 0.5 back to 1.0 height
                        duckHeight = 0.5 + (0.5 * phaseProgress);
                        isDucking = duckHeight < 0.75; // Only counting as ducked while mostly down
                    }
                    
                    // Apply the current duck height
                    player.scale.y = duckHeight;
                    player.position.y = DEFAULT_Y * duckHeight;
                    
                    duckAnimationId = requestAnimationFrame(duckAnimation);
                }
                
                // Start the duck animation
                duckAnimation();
            }
            
            // Create obstacle with optimized geometry
            function createObstacle(type) {
                let obstacleGeometry, obstacleMaterial;
                
                // Set first obstacle spawned flag
                firstObstacleSpawned = true;
                
                if (type === 0) {
                    // Low obstacle (jump over) - simpler on low-performance devices
                    obstacleGeometry = new THREE.BoxGeometry(1, 0.5, 0.5);
                    obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
                } else {
                    // High obstacle (duck under) - Simplified on mobile
                    if (LOW_PERFORMANCE_MODE) {
                        // Simplified duck for mobile
                        obstacleGeometry = new THREE.BoxGeometry(1, 0.8, 0.7);
                        obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                        
                        let obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                        obstacle.position.y = 1.0;
                        obstacle.position.z = -50;
                        obstacle.castShadow = SHADOW_ENABLED;
                        obstacle.userData = { type: type, passed: false, hit: false };
                        
                        scene.add(obstacle);
                        obstacles.push(obstacle);
                        return;
                    } else {
                        // Detailed duck for higher-end devices
                        obstacleGeometry = new THREE.Group();
                        
                        // Duck body
                        const bodyGeo = new THREE.BoxGeometry(1, 0.8, 0.7);
                        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                        const body = new THREE.Mesh(bodyGeo, bodyMat);
                        body.position.y = 0.2;
                        body.castShadow = SHADOW_ENABLED;
                        obstacleGeometry.add(body);
                        
                        // Duck head
                        const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                        const headMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                        const head = new THREE.Mesh(headGeo, headMat);
                        head.position.set(0, 0.8, 0.2);
                        head.castShadow = SHADOW_ENABLED;
                        obstacleGeometry.add(head);
                        
                        // Duck bill
                        const billGeo = new THREE.BoxGeometry(0.3, 0.2, 0.3);
                        const billMat = new THREE.MeshStandardMaterial({ color: 0xFFA500 });
                        const bill = new THREE.Mesh(billGeo, billMat);
                        bill.position.set(0, 0.8, 0.5);
                        bill.castShadow = SHADOW_ENABLED;
                        obstacleGeometry.add(bill);
                    }
                    
                    // Create material for placeholder
                    obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                }
                
                let obstacle;
                if (type === 0) {
                    obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                    obstacle.position.y = 0.25;
                } else {
                    obstacle = obstacleGeometry;
                    // Position the duck at a height where it will hit the player unless they duck
                    obstacle.position.y = 1.0;
                }
                
                obstacle.position.z = -50;
                obstacle.castShadow = SHADOW_ENABLED;
                obstacle.userData = { type: type, passed: false, hit: false };
                
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
            
            // Check for collisions between player and obstacles
            function checkCollisions() {
                if (isInvincible) return;
                
                const playerBoundingBox = new THREE.Box3().setFromObject(player);
                
                for (const obstacle of obstacles) {
                    if (obstacle.position.z > 2) continue; // Skip obstacles that are behind the player
                    if (obstacle.userData.hit) continue; // Skip already hit obstacles
                    
                    const obstacleBoundingBox = new THREE.Box3().setFromObject(obstacle);
                    
                    // Check collision based on obstacle type
                    if (obstacle.userData.type === 0) {
                        // Low obstacle - we hit it if we're not jumping
                        if (playerBoundingBox.intersectsBox(obstacleBoundingBox) && !isJumping) {
                            // Mark the obstacle as "hit" so it won't award points later
                            obstacle.userData.hit = true;
                            handleCollision();
                            break;
                        }
                    } else {
                        // High obstacle - we hit it if we're not ducking
                        if (playerBoundingBox.intersectsBox(obstacleBoundingBox) && !isDucking) {
                            // Mark the obstacle as "hit" so it won't award points later
                            obstacle.userData.hit = true;
                            handleCollision();
                            break;
                        }
                    }
                }
            }
            
            // Handle player collision with obstacle
            function handleCollision() {
                lives--;
                updateLivesDisplay();
                
                if (lives <= 0) {
                    gameOver();
                } else {
                    // Make player invincible for a short period
                    isInvincible = true;
                    
                    // Visual feedback for invincibility
                    let blinkCount = 0;
                    const blinkInterval = setInterval(() => {
                        player.visible = !player.visible;
                        blinkCount++;
                        
                        if (blinkCount >= 10) {
                            clearInterval(blinkInterval);
                            player.visible = true;
                            isInvincible = false;
                        }
                    }, 200);
                }
            }
            
            // Update score when obstacle is passed
            function updateScoreForPassedObstacles() {
                for (const obstacle of obstacles) {
                    // Only award points for obstacles that:
                    // 1. Have gone past the player (z > 0)
                    // 2. Haven't been counted yet (!passed)
                    // 3. Weren't hit by the player (!hit)
                    if (obstacle.position.z > 0 && !obstacle.userData.passed && !obstacle.userData.hit) {
                        obstacle.userData.passed = true;
                        score++;
                        updateScoreDisplay();
                        
                        // Make the obstacle semi-transparent when passed
                        // For duck-themed obstacles (type 1), we need to apply transparency to all children
                        if (obstacle.userData.type === 1) {
                            obstacle.traverse((child) => {
                                if (child.isMesh) {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.3;
                                }
                            });
                        } else {
                            // For simple obstacles (type 0)
                            obstacle.material.transparent = true;
                            obstacle.material.opacity = 0.3;
                        }
                        
                        // Update difficulty every point for smoother scaling
                        updateDifficulty();
                    }
                }
            }
            
            // Separate function to handle difficulty updates
            function updateDifficulty() {
                // Increase difficulty, capping at MAX_DIFFICULTY_SCORE
                if (score <= MAX_DIFFICULTY_SCORE) {
                    // Calculate progress towards max difficulty (0 to 1)
                    const progressToMax = score / MAX_DIFFICULTY_SCORE;
                    
                    // More aggressive early-game scaling for obstacle speed
                    // Uses a cubic curve for initial boost, then more gradual scaling
                    const speedProgress = Math.pow(progressToMax, score < 50 ? 1.2 : 1.7);
                    obstacleSpeed = INITIAL_OBSTACLE_SPEED + 
                                   (MAX_OBSTACLE_SPEED - INITIAL_OBSTACLE_SPEED) * speedProgress;
                    
                    // Early game (score 0-20): Random spacing between 1.0 and 1.5 seconds
                    if (score <= EARLY_GAME_THRESHOLD) {
                        nextObstacleDistance = EARLY_GAME_MIN_SPACING + 
                                              (Math.random() * (EARLY_GAME_MAX_SPACING - EARLY_GAME_MIN_SPACING));
                    } 
                    // Mid game (score 21-49): Introduce occasional sub-1 second spacing
                    else if (score < MID_GAME_THRESHOLD) {
                        // Base spacing decreases with score
                        const baseSpacing = EARLY_GAME_MIN_SPACING - (0.3 * (score - EARLY_GAME_THRESHOLD) / 30);
                        
                        // 20% chance of a quick sub-1 second obstacle
                        if (Math.random() < 0.2) {
                            nextObstacleDistance = Math.max(0.75, baseSpacing - 0.5 + (Math.random() * 0.3));
                        } else {
                            // Normal spacing with some variation
                            nextObstacleDistance = baseSpacing + (Math.random() * 0.4);
                        }
                    }
                    // Intense game (score 50+): More aggressive with rhythmic bursts and pauses
                    else {
                        // Check if we're currently in a pause after a burst
                        if (postBurstPause) {
                            const currentTime = Date.now() / 1000;
                            if (currentTime >= pauseEndTime) {
                                // Pause is over, return to normal gameplay
                                postBurstPause = false;
                            } else {
                                // Still in pause, set a longer distance
                                nextObstacleDistance = 1.5 + (Math.random() * 0.5);
                                return;
                            }
                        }
                        
                        // Check if we should start a new burst sequence
                        if (!burstMode && !patternMode && Math.random() < 0.3) {
                            startBurstMode();
                        }
                        
                        if (burstMode) {
                            // We're in burst mode, create tight sequences of obstacles
                            handleBurstMode();
                        } else {
                            // Normal intense difficulty scaling - use late game calculation
                            // Calculate base spacing that decreases as score approaches max
                            const lateGameProgress = Math.min(1, (score - MID_GAME_THRESHOLD) / (MAX_DIFFICULTY_SCORE - MID_GAME_THRESHOLD));
                            
                            // Non-linear curve for more dramatic spacing reduction
                            const baseSpacing = 0.9 - (0.4 * Math.pow(lateGameProgress, 1.2));
                            
                            // Add randomization to keep player on their toes
                            const randomVariation = Math.max(0.05, 0.25 - (0.15 * lateGameProgress));
                            nextObstacleDistance = Math.max(MIN_OBSTACLE_DISTANCE_AT_MAX, 
                                                        baseSpacing + (Math.random() * randomVariation) - (randomVariation / 2));
                        }
                    }
                    
                    // After score 50, occasionally generate patterns of obstacles
                    if (score >= MID_GAME_THRESHOLD && Math.random() < 0.25 && !patternMode && !burstMode) {
                        generateObstaclePattern();
                    }
                }
            }
            
            // Start a burst sequence of obstacles
            function startBurstMode() {
                burstMode = true;
                burstCount = 0;
                
                // Determine length of burst based on score
                const burstDifficultyFactor = Math.min(1, (score - MID_GAME_THRESHOLD) / (MAX_DIFFICULTY_SCORE - MID_GAME_THRESHOLD));
                maxBurstCount = Math.floor(3 + (burstDifficultyFactor * 4)); // 3-7 obstacles in a burst
                
                console.log("Starting burst mode: " + maxBurstCount + " obstacles");
            }
            
            // Handle obstacle spacing during burst mode
            function handleBurstMode() {
                burstCount++;
                
                // Tight spacing for burst mode obstacles
                const burstDifficultyFactor = Math.min(1, (score - MID_GAME_THRESHOLD) / (MAX_DIFFICULTY_SCORE - MID_GAME_THRESHOLD));
                const minBurstSpacing = 0.6 - (0.15 * burstDifficultyFactor);
                const maxBurstSpacing = 0.8 - (0.2 * burstDifficultyFactor);
                
                // Set tighter spacing for burst obstacles
                nextObstacleDistance = minBurstSpacing + (Math.random() * (maxBurstSpacing - minBurstSpacing));
                
                // Check if burst sequence is complete
                if (burstCount >= maxBurstCount) {
                    burstMode = false;
                    
                    // Set a pause before next obstacles
                    postBurstPause = true;
                    pauseEndTime = (Date.now() / 1000) + 1.5 + (Math.random() * 0.5); // 1.5-2 second pause
                    
                    console.log("Burst complete, pausing until: " + pauseEndTime);
                }
            }
            
            // Generate a challenging but fair pattern of obstacles
            function generateObstaclePattern() {
                patternMode = true;
                currentPatternIndex = 0;
                
                // Create patterns of 2-5 obstacles that require precise timing
                // Higher score = longer patterns
                const patternLengthFactor = Math.min(1, (score - MID_GAME_THRESHOLD) / (MAX_DIFFICULTY_SCORE - MID_GAME_THRESHOLD));
                const baseLength = Math.floor(2 + (patternLengthFactor * 3)); // 2-5 obstacles
                const patternLength = baseLength + (Math.random() < 0.3 ? 1 : 0); // Occasional +1
                
                currentPattern = [];
                
                // For patterns, use tighter spacing to create rhythm challenges
                // But not quite as tight as burst mode
                const patternDifficultyFactor = Math.min(1, (score - MID_GAME_THRESHOLD) / (MAX_DIFFICULTY_SCORE - MID_GAME_THRESHOLD));
                const minPatternSpacing = 0.7 - (0.2 * patternDifficultyFactor);
                const maxPatternSpacing = 0.9 - (0.2 * patternDifficultyFactor);
                
                nextObstacleDistance = minPatternSpacing + (Math.random() * (maxPatternSpacing - minPatternSpacing));
                
                // First obstacle is random
                currentPattern.push(Math.random() > 0.5 ? 1 : 0);
                
                // Generate rest of pattern with more variety but balanced challenge
                for (let i = 1; i < patternLength; i++) {
                    const prevType = currentPattern[i-1];
                    const prevPrevType = i > 1 ? currentPattern[i-2] : -1;
                    
                    // Create more varied patterns based on score
                    if (score > 150) {
                        // At higher scores, patterns can be more challenging
                        // But avoid triple same-type obstacles (too easy to stay in one state)
                        if (prevType === prevPrevType) {
                            currentPattern.push(1 - prevType); // Opposite type
                        } else {
                            // Higher chance of alternating patterns at high scores
                            const randomFactor = Math.random();
                            if (randomFactor < 0.6) {
                                // 60% chance of alternating pattern (more challenging)
                                currentPattern.push(1 - prevType);
                            } else {
                                // 40% chance of same type (gives brief respite)
                                currentPattern.push(prevType);
                            }
                        }
                    } else {
                        // At mid scores, patterns are more forgiving
                        // Avoid triple same-type obstacles
                        if (prevType === prevPrevType) {
                            currentPattern.push(1 - prevType); // Opposite type
                        } else {
                            // 50/50 chance
                            currentPattern.push(Math.random() > 0.5 ? 1 : 0);
                        }
                    }
                }
                
                console.log("Pattern generated: " + patternLength + " obstacles");
            }
            
            // Update score display
            function updateScoreDisplay() {
                document.getElementById('score-display').textContent = `Score: ${score}`;
            }
            
            // Update lives display
            function updateLivesDisplay() {
                const livesContainer = document.querySelector('.lives-container');
                livesContainer.innerHTML = '';
                
                // Create circles for each life
                for (let i = 0; i < lives; i++) {
                    const lifeCircle = document.createElement('div');
                    lifeCircle.className = 'life-circle';
                    livesContainer.appendChild(lifeCircle);
                }
            }
            
            // Toggle pause function
            function togglePause() {
                if (!gameStarted || !gameRunning) return;
                
                gamePaused = !gamePaused;
                
                if (gamePaused) {
                    // Show pause screen
                    document.getElementById('pause-screen').style.display = 'flex';
                } else {
                    // Hide pause screen
                    document.getElementById('pause-screen').style.display = 'none';
                    
                    // Update lastObstacleTime to prevent instant obstacle spawn when unpausing
                    lastObstacleTime = Date.now() / 1000;
                }
            }
            
            // Game over function
            function gameOver() {
                gameRunning = false;
                firstObstacleSpawned = false;
                
                // Clear any ongoing animations
                if (jumpAnimationId) {
                    cancelAnimationFrame(jumpAnimationId);
                    jumpAnimationId = null;
                }
                
                if (duckAnimationId) {
                    cancelAnimationFrame(duckAnimationId);
                    duckAnimationId = null;
                }
                
                // Hide the lives display
                document.getElementById('lives-display').style.display = 'none';
                
                document.getElementById('final-score').textContent = `Final Score: ${score}`;
                document.getElementById('game-over').style.display = 'block';
            }
            
            // Restart game function
            function restartGame() {
                // Hide game over screen immediately
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('pause-screen').style.display = 'none';
                
                // Show the lives display again
                document.getElementById('lives-display').style.display = 'flex';
                
                // Reset game state
                score = 0;
                updateScoreDisplay();
                lives = 3;
                updateLivesDisplay();
                obstacleSpeed = INITIAL_OBSTACLE_SPEED;
                baseDifficulty = 1.0;
                difficultyFactor = 1.0;
                
                // Reset obstacle spacing to initial values
                nextObstacleDistance = EARLY_GAME_MIN_SPACING + 
                                     (Math.random() * (EARLY_GAME_MAX_SPACING - EARLY_GAME_MIN_SPACING));
                minObstacleDistance = INITIAL_MIN_OBSTACLE_DISTANCE;
                
                // Reset pattern and burst generation
                patternMode = false;
                currentPattern = [];
                currentPatternIndex = 0;
                burstMode = false;
                burstCount = 0;
                postBurstPause = false;
                
                // Reset player position, scale and visibility
                player.position.y = DEFAULT_Y;
                player.scale.y = 1.0;
                player.visible = true;
                
                // Reset input state
                isDownKeyPressed = false;
                isJumping = false;
                isDucking = false;
                isInDuckAnimation = false;
                duckAnimationPhase = 0;
                isInvincible = false;
                
                // Clear any active animations
                if (jumpAnimationId) {
                    cancelAnimationFrame(jumpAnimationId);
                    jumpAnimationId = null;
                }
                if (duckAnimationId) {
                    cancelAnimationFrame(duckAnimationId);
                    duckAnimationId = null;
                }
                
                // Remove all obstacles
                for (const obstacle of obstacles) {
                    scene.remove(obstacle);
                }
                obstacles = [];
                
                // Make player responsive immediately
                inputsActive = true;
                
                // Force focus on the game container
                document.getElementById('game-container').focus();
                
                // Render initial state
                renderer.render(scene, camera);
                
                // Start countdown and begin game after countdown
                startCountdown(() => {
                    // Set game state variables after countdown
                    gameStarted = true;
                    gameRunning = true;
                    firstObstacleSpawned = false;
                    
                    // Set last obstacle time
                    lastObstacleTime = Date.now() / 1000;
                    
                    // Create first obstacle faster (after 1 second)
                    setTimeout(() => {
                        // Choose a random obstacle type for the first one
                        const firstObstacleType = Math.random() > 0.5 ? 1 : 0;
                        createObstacle(firstObstacleType);
                    }, 1000);
                });
            }
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                try {
                    frameCount++;
                    
                    // Skip rendering on some frames for low-performance devices
                    if (LOW_PERFORMANCE_MODE && frameCount % ANIMATION_FRAME_THROTTLE !== 0) {
                        return;
                    }
                    
                    // Allow input handling during countdown or during active game
                    inputsActive = gameStarted || gameRunning || countdownActive;
                    
                    if (gameRunning && !gamePaused) {
                        // Move ground to create illusion of movement
                        ground.position.z += obstacleSpeed;
                        if (ground.position.z > 30) {
                            ground.position.z = -20;
                        }
                        
                        // Move obstacles
                        const objectsToRemove = [];
                        
                        for (let i = obstacles.length - 1; i >= 0; i--) {
                            const obstacle = obstacles[i];
                            obstacle.position.z += obstacleSpeed;
                            
                            // Queue removal of obstacles that have gone past the camera
                            if (obstacle.position.z > 10) {
                                objectsToRemove.push(i);
                            }
                        }
                        
                        // Batch remove obstacles for performance
                        if (objectsToRemove.length > 0) {
                            for (let i = objectsToRemove.length - 1; i >= 0; i--) {
                                const index = objectsToRemove[i];
                                scene.remove(obstacles[index]);
                                obstacles.splice(index, 1);
                            }
                        }
                        
                        // Smart obstacle spawning system
                        const currentTime = Date.now() / 1000; // convert to seconds
                        
                        // Skip the timed spawning for the first obstacle since we're using setTimeout
                        // Only apply normal spawning logic after the first obstacle has been created
                        if (firstObstacleSpawned && currentTime - lastObstacleTime > nextObstacleDistance) {
                            // Determine obstacle type based on pattern or random generation
                            let obstacleType;
                            
                            if (patternMode) {
                                // Use the next obstacle in the pattern
                                obstacleType = currentPattern[currentPatternIndex];
                                currentPatternIndex++;
                                
                                // Reset pattern mode when pattern is complete
                                if (currentPatternIndex >= currentPattern.length) {
                                    patternMode = false;
                                    
                                    // After pattern, give a slight breather
                                    nextObstacleDistance = 1.2 + (Math.random() * 0.3);
                                }
                            } else {
                                // Choose obstacle type with pure randomness - true coin flip
                                obstacleType = Math.random() > 0.5 ? 1 : 0;
                            }
                            
                            createObstacle(obstacleType);
                            lastObstacleTime = currentTime;
                            
                            // Calculate next obstacle distance based on current difficulty
                            updateDifficulty();
                        }
                        
                        // Check for collisions
                        checkCollisions();
                        
                        // Update score for passed obstacles
                        updateScoreForPassedObstacles();
                    }
                    
                    // Always render the scene to show player response to input
                    // This ensures player actions are visible immediately
                    renderer.render(scene, camera);
                } catch (error) {
                    console.error("Error in animation loop:", error);
                    // Try to recover by resetting game state if possible
                    if (gameRunning) {
                        gameOver();
                    }
                }
            }
            
            // Initialize the game
            init();
        });
    </script>
</body>
</html>
